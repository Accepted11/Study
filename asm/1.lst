Microsoft (R) Macro Assembler Version 6.11		    06/21/20 17:20:36
tempfile.asm						     Page 1 - 1


				;=======================================================
				; 文件名: Keyscan.asm
				; 功能描述: 键盘及数码管显示实验，通过8255控制。
				;     8255的 B口控制数码管的段显示，
				;            A口控制键盘列扫描及数码管的位驱动，
				;            C口控制键盘的行扫描。
				;     按下按键，该按键对应的位置将按顺序显示在数码管上。
				;=======================================================

 = 0600				IOY0         EQU   0600H          ;片选IOY0对应的端口始地址
 = 0600				MY8255_A     EQU   IOY0+00H*2     ;8255的A口地址
 = 0602				MY8255_B     EQU   IOY0+01H*2     ;8255的B口地址
 = 0604				MY8255_C     EQU   IOY0+02H*2     ;8255的C口地址
 = 0606				MY8255_CON   EQU   IOY0+03H*2     ;8255的控制寄存器地址

 0000				SSTACK	SEGMENT STACK
 0000  0010 [					DW 16 DUP(?)
        0000
       ]
 0020				SSTACK	ENDS		

 0000				DATA  	SEGMENT

				; DATBLE是 将需要输入按键的值对应需要给的显示器的值
				; 比如按键1表示的值是1 但是我们送给显示器的是06H
				; 该程序是通过判断按键按下 获取其代表的偏移量（相对于DTABLE）
				; 比如按键1的偏移量是1 我们扫描按键 得出一个值 1
				; 然后利用该值在DTABLE中找到需要输出值的对应显示代码值
				; 从B口送出去即可

 0000 3F 06 5B 4F 66 6D		DTABLE	DB 3FH,06H,5BH,4FH,66H,6DH,7DH,07H
       7D 07
 0008  7F 6F 77 7C 39 5E			DB 7FH,6FH,77H,7CH,39H,5EH,79H,71H
       79 71
 0010				DATA  	ENDS

 0000				CODE 	SEGMENT
				      	ASSUME CS:CODE,DS:DATA
 0000				START:
						
 0000  B8 ---- R				MOV AX,DATA
 0003  8E D8					MOV DS,AX
				 		
				 		; 把3000H--3005H中的值全部初始化为00H
				 		; 说明初始偏移量全为0(3000H--3005H)
 0005  BE 3000			 		MOV SI,3000H
 0008  B0 00					MOV AL,00H
						
 000A  88 04					MOV [SI],AL					;清显示缓冲
 000C  88 44 01					MOV [SI+1],AL
 000F  88 44 02					MOV [SI+2],AL
 0012  88 44 03					MOV [SI+3],AL
 0015  88 44 04					MOV [SI+4],AL
 0018  88 44 05					MOV [SI+5],AL
						
						
 001B  BF 3005					MOV DI,3005H
						
 001E  BA 0606					MOV DX,MY8255_CON			;8255控制字初始化
 0021  B0 81					MOV AL,81H					;1000 0001    A、B口输出 C口输入
 0023  EE					OUT DX,AL

 0024				BEGIN:	
						; 调用显示子程序 
 0024  E8 0081					CALL DIS			
						
						;清屏	
 0027  E8 0077					CALL CLEAR					
						
						;扫描 看是否有键按下
 002A  E8 0065					CALL CCSCAN					
						
						;有键按下 跳INK1
 002D  75 02					JNZ INK1       
						
 002F  EB F3					JMP BEGIN

 0031				INK1:	
 0031  E8 0074			 		CALL DIS
 0034  E8 00A1					CALL DALLY
 0037  E8 009E					CALL DALLY
 003A  E8 0064					CALL CLEAR
 003D  E8 0052					CALL CCSCAN
						
						; 若结果不为0 ZF=0 则说明一定有键按下 则跳转 判断哪个键按下
 0040  75 02					JNZ INK2					
 0042  EB E0					JMP BEGIN
						
						;确定按下键的位置
 0044				INK2:	
 0044  B5 FE					MOV CH,0FEH 	; FEH=1111 1110（对应关系：PA7 PA6..PA1 PA0 ） 
				                    	; PA5-PA0=1111 10 (这里对应关系要弄明白)     
				                    	;PA0对应的按键则是 从左到右第一列（这里不会晕哦）                  
 0046  B1 00					MOV CL,00H      ; 初始对于行的偏移量 为0 

						;列循环 即扫描列 从第一列开始
 0048				COLUM:	
 0048  8A C5					MOV AL,CH
 004A  BA 0600					MOV DX,MY8255_A 
 004D  EE					OUT DX,AL   
						
 004E  BA 0604					MOV DX,MY8255_C 
 0051  EC					IN AL,DX
 0052  A8 01			L1:		TEST AL,01H         			;is L1?
 0054  75 04					JNZ L2
 0056  B0 00					MOV AL,00H          			;L1
 0058  EB 16					JMP KCODE
 005A  A8 02			L2:		TEST AL,02H         			;is L2?
 005C  75 04					JNZ L3
 005E  B0 04					MOV AL,04H          			;L2
 0060  EB 0E					JMP KCODE
 0062  A8 04			L3:		TEST AL,04H         			;is L3?
 0064  75 04					JNZ L4
 0066  B0 08					MOV AL,08H          			;L3
 0068  EB 06					JMP KCODE
 006A  A8 08			L4:		TEST AL,08H         			;is L4?
 006C  75 14					JNZ NEXT
 006E  B0 0C					MOV AL,0CH          			;L4

				; 找到按键后 此时AL存的的第一列每一行的初始值 0 4 8 C
				; CL 存的是对应行的偏移量
				; 假设 AL为08H CL为2 则表示的总偏移量为 8+2=10H
				; 说明在table中该数字的偏移量为10H
				; 输出该数字 利用偏移量就行 因为数字其实是存在table中的
 0070  02 C1			KCODE:	ADD AL,CL
 0072  E8 0071					CALL PUTBUF
 0075  50					PUSH AX
 0076  E8 002F			KON: 	CALL DIS
 0079  E8 0025					CALL CLEAR
 007C  E8 0013					CALL CCSCAN
 007F  75 F5					JNZ KON
 0081  58					POP AX
 0082  FE C1			NEXT:	INC CL  ; CL相当于 行偏移量
 0084  8A C5					MOV AL,CH
 0086  A8 08					TEST AL,08H 	; 08H=0000 1000 当AL为1111 0111 && 0000 1000 结果为0 
						             	; ZF=1 说明行偏移量达到最大值 3
 0088  74 06					JZ KERR 		;  4次列循环结束 跳KERR
 008A  D0 C0					ROL AL,1
 008C  8A E8					MOV CH,AL
 008E  EB B8					JMP COLUM
 0090  EB 92			KERR:	JMP BEGIN


				; 键盘扫描子程序
				; 原理是 先向全部列输出低电平
				; 然后从C口读入 行电平
				; 如果没有按键按下 所有行应该均为高电平 
				; 反之 若有按键按下 则开始仔细判断出到底是哪个按键按下 具体判断方法是：
				; 先向第一列输出低电平（从左到右）
				; 然后从C口读入行电平 利用 AND 
				; 判断哪一行是否为低电平即可(后面为了计算方便取反了行电平)
				; 若行全为高 为开始向下一列输出低电平 循环4次即可
 0092  B0 00			CCSCAN:	MOV AL,00H	 				
 0094  BA 0600					MOV DX,MY8255_A  
 0097  EE					OUT DX,AL		; 向所有列输出 低电平
 0098  BA 0604					MOV DX,MY8255_C 
 009B  EC					IN  AL,DX       ;读所有行电平
						
						;原来没有任何键按下 4行全为1
						;这里取反 变成 0000 便于后面的判断
 009C  F6 D0					NOT AL
						
						; 假设没有按键按下 
					 	; 0000&1111=0
						; 结果为0 ZF=1 
 009E  24 0F					AND AL,0FH
 00A0  C3					RET

				;清屏子程序
				;就是使得所有的灯熄灭 00H表示全不亮 瞬间 很快 
 00A1  BA 0602			CLEAR:	MOV DX,MY8255_B 			
 00A4  B0 00					MOV AL,00H
 00A6  EE					OUT DX,AL
 00A7  C3		RET


				; 显示子程序 (这里稍微有点绕)
 00A8  50			DIS:	PUSH AX					
 00A9  BE 3000					MOV SI,3000H
						
						; 0DFH=1101 1111 对应PA7 PA6 PA5...PA1 PA0
						; 由电路图 得出 X1-PA0 X2-PA1.....
						; 6个显示器 从左到右依次是 X1 X2 X3... X5 X6
						; 所以 对应的PA:          PA0 PA1 PA2...PA4 PA5
						; 这里初始是0DFH   代表    1  1 1 1 1 0 
						; 意思是 第六个显示 开始显示数字
						; 哈哈 这里其实是从X6到X1依次显示的
						; 每个数字显示间隔很快 我们会认为是6个数字一起显示 其实是逐个显示
 00AC  B2 DF					MOV DL,0DFH
 00AE  8A C2					MOV AL,DL

 00B0  52			AGAIN:	PUSH DX
						; 把AL送给A口 觉得开放哪个灯 （这里要看电路图 A口也控制灯的开放）
 00B1  BA 0600					MOV DX,MY8255_A 
 00B4  EE					OUT DX,AL
						
						
 00B5  8A 04					MOV AL,[SI]  				; 把3000H--3005H中存的偏移量（相对）取出
 00B7  BB 0000 R				MOV BX,OFFSET DTABLE		; 获取DTABLE的首地址
 00BA  25 00FF					AND AX,00FFH           		;因为后面会有加法运算 先把ah清0 这样ax就是						 
													; al的值，防止出错
 00BD  03 D8					ADD BX,AX                   ; 获取需要的值的偏移量（这个是绝对偏移量）
 00BF  8A 07					MOV AL,[BX]         		; 获取显示数字需要的值 例 显示0需要3FH
					
 00C1  BA 0602					MOV DX,MY8255_B   			; 送往B口 显示数字
 00C4  EE					OUT DX,AL
					
 00C5  E8 0010					CALL DALLY 					;延时
 00C8  46					INC SI              		;移动SI 读取下一个偏移量
 00C9  5A					POP DX
 00CA  8A C2					MOV AL,DL					; DL: 控制哪个灯的开放 开始是0DF 1101 1111
													; 取后6位（看电路图 只连了6根线）即01 1111
													; 赋值给AL
 00CC  A8 01					TEST AL,01H            		; 测试AL 看是否为11 1110 
													; 6个灯 一次显示需要循环6次
													; 这里第六次结束是 AL=11 1110
													; 对于灯 就是x1灯显示完（灯：X6->X1）
 00CE  74 06					JZ  OUT1 					; 6次循环完成后 跳出
 00D0  D0 C8					ROR AL,1					; 循环右移
													; 例 第一个灯亮 AL=01 1111 
													;  则 第二个灯亮 为 10 1111
													;  所以需要循环右移
													;  反映在灯上 则是左移（不要绕进去了哦）
 00D2  8A D0					MOV DL,AL
 00D4  EB DA					JMP AGAIN           		; 跳回 继续显示 需循环6次
 00D6  58			OUT1:	POP AX
 00D7  C3					RET

				; 子程序 延时作用 RET为子程序结束标记
 00D8  51			DALLY:	PUSH CX						
 00D9  B9 0006					MOV CX,0006H
 00DC  B8 009F			T1:		MOV AX,009FH
 00DF  48			T2:		DEC AX
 00E0  75 FD					JNZ T2
 00E2  E2 F8					LOOP T1
 00E4  59					POP CX
 00E5  C3					RET

				; 将获得的偏移量存入3000H--30005H中
				; 便于后面的显示 
				; 显示其实就是从3000H--3005H中读取偏移量
				; 然后在table中找到真正的值即可
 00E6  8B F7			PUTBUF:	MOV SI,DI					;存键盘值到相应位的缓冲中
 00E8  88 04					MOV [SI],AL  ;先存入地址3005H 再递减 也就是下一个存入偏移量的是3004H
 00EA  4F					DEC DI
 00EB  81 FF 2FFF				CMP DI,2FFFH
 00EF  75 03					JNZ GOBACK
 00F1  BF 3005					MOV DI,3005H
 00F4  C3			GOBACK:	RET

 00F5				CODE	ENDS
						END START


Microsoft (R) Macro Assembler Version 6.11		    06/21/20 17:20:36
tempfile.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CODE . . . . . . . . . . . . . .	16 Bit	 00F5	  Para	  Private 
DATA . . . . . . . . . . . . . .	16 Bit	 0010	  Para	  Private 
SSTACK . . . . . . . . . . . . .	16 Bit	 0020	  Para	  Stack	  


Symbols:

                N a m e                 Type     Value    Attr

AGAIN  . . . . . . . . . . . . .	L Near	 00B0	  CODE	
BEGIN  . . . . . . . . . . . . .	L Near	 0024	  CODE	
CCSCAN . . . . . . . . . . . . .	L Near	 0092	  CODE	
CLEAR  . . . . . . . . . . . . .	L Near	 00A1	  CODE	
COLUM  . . . . . . . . . . . . .	L Near	 0048	  CODE	
DALLY  . . . . . . . . . . . . .	L Near	 00D8	  CODE	
DIS  . . . . . . . . . . . . . .	L Near	 00A8	  CODE	
DTABLE . . . . . . . . . . . . .	Byte	 0000	  DATA	
GOBACK . . . . . . . . . . . . .	L Near	 00F4	  CODE	
INK1 . . . . . . . . . . . . . .	L Near	 0031	  CODE	
INK2 . . . . . . . . . . . . . .	L Near	 0044	  CODE	
IOY0 . . . . . . . . . . . . . .	Number	 0600h	 
KCODE  . . . . . . . . . . . . .	L Near	 0070	  CODE	
KERR . . . . . . . . . . . . . .	L Near	 0090	  CODE	
KON  . . . . . . . . . . . . . .	L Near	 0076	  CODE	
L1 . . . . . . . . . . . . . . .	L Near	 0052	  CODE	
L2 . . . . . . . . . . . . . . .	L Near	 005A	  CODE	
L3 . . . . . . . . . . . . . . .	L Near	 0062	  CODE	
L4 . . . . . . . . . . . . . . .	L Near	 006A	  CODE	
MY8255_A . . . . . . . . . . . .	Number	 0600h	 
MY8255_B . . . . . . . . . . . .	Number	 0602h	 
MY8255_CON . . . . . . . . . . .	Number	 0606h	 
MY8255_C . . . . . . . . . . . .	Number	 0604h	 
NEXT . . . . . . . . . . . . . .	L Near	 0082	  CODE	
OUT1 . . . . . . . . . . . . . .	L Near	 00D6	  CODE	
PUTBUF . . . . . . . . . . . . .	L Near	 00E6	  CODE	
START  . . . . . . . . . . . . .	L Near	 0000	  CODE	
T1 . . . . . . . . . . . . . . .	L Near	 00DC	  CODE	
T2 . . . . . . . . . . . . . . .	L Near	 00DF	  CODE	

	   0 Warnings
	   0 Errors
